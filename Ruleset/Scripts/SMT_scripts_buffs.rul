extended:
  tagsFile: Ruleset/Scripts/SMT_tags.rul

  scripts:
    newTurnUnit:
      - new: SMTS_misc_removebuff #*** Script that removes tags from units once turn ends ***
        offset: 90.0
        code: |
          var int currTurn;
          var int endTurn;
          var int baseMove;
          var int hasteMove;

          if neq side 0; # only run at the start of the players turn
            return;
          end;
          battle_game.getTurn currTurn;

          unit.getTag endTurn Tag.SMT_HASTE_ENDTURN; ## Haste
          if neq endTurn 0;
            if or le currTurn 1 ge currTurn endTurn; # if buff expires or it's turn 1 (entering a new stage of multi-part mission)
              unit.getTag hasteMove Tag.SMT_HASTE_SPEED_BONUS;
              if neq hasteMove 0;
                unit.getTag baseMove Tag.UNIT_MOVESPEED_MODIFIERS;
                sub baseMove hasteMove;
                unit.setTag Tag.UNIT_MOVESPEED_MODIFIERS baseMove;
                add baseMove 100;
                limit_lower baseMove 25;
                unit.MoveCost.setBaseTimePercent baseMove;
                unit.setTag Tag.SMT_HASTE_SPEED_BONUS 0; #cancel tag
              end;
              unit.setTag Tag.SMT_HASTE_ENDTURN 0; #cancel tag
              #debug_log "HasteEnd Ping" currTurn endTurn;
            end;
          end;

          unit.getTag endTurn Tag.SMT_REFLEX_ENDTURN; ## Reflex
          if neq endTurn 0;
            if or le currTurn 1 ge currTurn endTurn; # if buff expires or it's turn 1 (entering a new stage of multi-part mission)
              unit.setTag Tag.SMT_REFLEX_REACTION_BONUS 0;
              unit.setTag Tag.SMT_REFLEX_ENDTURN 0; #cancel tags
              #debug_log "ReflexEnd Ping" currTurn endTurn;
            end;
          end;

          unit.getTag endTurn Tag.SMT_OVERWATCH_BUFF_ENDTURN; ## Vigilance
          if neq endTurn 0;
            if or le currTurn 1 ge currTurn endTurn; # if buff expires or it's turn 1 (entering a new stage of multi-part mission)
              unit.setTag Tag.SMT_OVERWATCH_BUFF 0;
              unit.setTag Tag.SMT_OVERWATCH_BUFF_EXCESS 0;
              unit.setTag Tag.SMT_OVERWATCH_BUFF_ENDTURN 0; #cancel tags
              #debug_log "VigilanceEnd Ping" currTurn endTurn;
            end;
          end;

          unit.getTag endTurn Tag.SMT_VULN_ENDTURN; ## Vulnerability
          if neq endTurn 0;
            if or le currTurn 1 ge currTurn endTurn; # if buff expires or it's turn 1 (entering a new stage of multi-part mission)
              unit.setTag Tag.SMT_VULN_INTENSITY 0;
              unit.setTag Tag.SMT_VULN_ENDTURN 0; #cancel tags
              #debug_log "VulnEnd Ping" currTurn endTurn;
            end;
          end;

          unit.setTag Tag.SMT_RAMPAGE_COUNT 0; # Rampage

          if eq currTurn 1;  # shield
            unit.setTag Tag.UNIT_SHIELD_COOLDOWN 0;
          end;

          return;

    damageUnit:
      - new: SMTS_buff_triggers # Buffs applied via weapon
        offset: 5
        code: |
          var int temp;
          var int temp2;

          begin; ### Vigilance
            var ptr RuleArmor armorRule;
            var int vigilBonus;

            damaging_item.getTag temp Tag.SMT_VIGILIANCE_BUFF;
            if gt temp 0; # skip if doesn't boost overwatch
              set vigilBonus orig_power;
              muldiv vigilBonus temp 100;
              unit.getRuleArmor armorRule;
              armorRule.getTag temp Tag.ARMOR_OVERWATCH_TU_RESTORED; # add innate Overwatch from armor
              add vigilBonus temp;
              unit.getTag temp Tag.SMT_OVERWATCH_BUFF; # add any previous Overwatch buffs
              add vigilBonus temp;
              unit.getTag temp Tag.SMT_OVERWATCH_BUFF_EXCESS; # add any overflow from previous Overwatch buffs
              add vigilBonus temp;
              if gt vigilBonus 100; # if total >100, add overflow TUs
                set temp vigilBonus;
                sub temp 100;
                unit.setTag Tag.SMT_OVERWATCH_BUFF_EXCESS temp;
              end;
              limit vigilBonus 0 100;
              unit.setTag Tag.SMT_OVERWATCH_BUFF vigilBonus;
              #debug_log "Vigilance Ping" vigilBonus temp;

              battle_game.getTurn temp;
              add temp 1; #define end turn for buff
              unit.setTag Tag.SMT_OVERWATCH_BUFF_ENDTURN temp;
            end;
          end;

          begin; ### Haste
            var int baseMove;

            damaging_item.getTag temp Tag.SMT_ITEM_MOVESPEED_BOOST; # movespeed bonus
            #debug_log "HasteBuff Ping " temp;
            if gt temp 0;
              # Power <50 = no change, >=50 = 75% cost, >=100 50% cost (move bonus capped by item tag)
              set temp2 orig_power;
              div temp2 50;
              #debug_log "HasteBuff Power - " temp orig_power currPower temp2;
              limit temp2 0 temp; # eliminate negatives and cap power
              if gt temp2 0; # only continue if move cost would change
                mul temp2 -25;
                unit.getTag temp Tag.SMT_HASTE_SPEED_BONUS;
                if lt temp2 temp; # if new value is faster
                  unit.getTag baseMove Tag.UNIT_MOVESPEED_MODIFIERS;
                  sub baseMove temp; # remove old modifier
                  add baseMove temp2; # add new modifier
                  unit.setTag Tag.UNIT_STEALTH_MOVEPENALTY temp2;
                  unit.setTag Tag.UNIT_MOVESPEED_MODIFIERS baseMove; # apply movement modifier
                  add baseMove 100;
                  limit_lower baseMove 25;
                  unit.MoveCost.setBaseTimePercent baseMove;
                end;
              end;
            battle_game.getTurn temp;
            add temp 1; #define end turn for buff
            unit.setTag Tag.SMT_HASTE_ENDTURN temp;
            end;
          end;

          begin; ### Reflexes
            var int currentReactBonus;

            damaging_item.getTag temp2 Tag.SMT_ITEM_REACTION_MOD; # reactions bonus
            if gt temp2 0;
              unit.getTag currentReactBonus Tag.SMT_REFLEX_REACTION_BONUS;
              set temp orig_power;
              add temp 25; # make low power more effective and high power slightly less effective
              muldiv temp 3 2;
              muldiv temp temp2 100; # scale result by item %
              if gt temp currentReactBonus; # only change if new bonus would be an improvement
                unit.setTag Tag.SMT_REFLEX_REACTION_BONUS temp;
              end;
              #debug_log "ReflexBuff Reaction Bonus N/O" temp currentReactBonus;
              battle_game.getTurn temp;
              add temp 1; #define end turn for buff
              unit.setTag Tag.SMT_REFLEX_ENDTURN temp;
            end;
          end;

          begin; ### Vulnerability
            var int debuffVal;

            damaging_item.getTag temp Tag.SMT_VULN_DEBUFF_MOD;
            damaging_item.getTag temp2 Tag.SMT_VULN_DEBUFF_FIXED;
            if or gt temp 0 gt temp2 0; # skip if doesn't inflict vuln
              set debuffVal currPower;
              muldiv debuffVal temp 100;
              add debuffVal temp2;
              limit debuffVal 0 200; # cap at 300%
              unit.getTag temp Tag.SMT_VULN_INTENSITY;
              if gt debuffVal temp; #only change if it would be higher
                unit.setTag Tag.SMT_VULN_INTENSITY debuffVal;
                #debug_log "VulnDebuff Ping 1" debuffVal;
                damaging_item.getTag debuffVal Tag.ITEM_EFFECT_DURATION;
                battle_game.getTurn temp;
                add temp debuffVal; #define end turn for buff
                unit.getTag temp2 Tag.SMT_VULN_ENDTURN;
                if gt temp temp2; # only set new endturn if incoming debuff duration is longer
                  unit.setTag Tag.SMT_VULN_ENDTURN temp;
                end;
                #debug_log "VulnDebuff Ping 2" temp;
              end;
            end;
          end;

          begin; ### Mend Wounds
            var int healWounds;
            var int numWounds;
            var int healthRestored;
            var int hpCap;

            damaging_item.getTag temp Tag.SMT_HEAL_WOUNDS_POW; # wounds restored
            set healWounds currPower;
            muldiv healWounds temp 100;
            if gt healWounds 0;
              loop var i 6; # cycle through the body parts
                unit.getFatalwounds numWounds i; # check the number of wounds in this bodypart
                if and gt numWounds 0 gt healWounds 0; # if there are any wounds in this body part and any heals remaining, remove as many as we can
                  set temp numWounds; # save the initial number of wounds
                  sub numWounds healWounds; # remove wounds equal to our heal wound count
                  limit_upper temp healWounds; # get total wounds healed
                  sub healWounds temp; # decrement the number of heals by the initial number of wounds
                  limit_lower numWounds 0; # ensure wounds do not go below 0
                  unit.setFatalwounds i numWounds; # remove the wounds
                end;
              end;
            end;

            damaging_item.getTag temp Tag.SMT_HEAL_WOUNDS_HP_CAP; # health cap
            if gt temp 0;
              unit.getHealthMax hpCap;
              unit.getTag temp2 Tag.SMT_LOWEST_HEALTH;
              #debug_log "HealWounds Hp Max/Low " hpCap temp2 temp;
              sub hpCap temp2;
              muldiv hpCap temp 100; # get health cap based on missing hp
              add hpCap temp2;
              damaging_item.getTag temp Tag.SMT_HEAL_WOUNDS_HP_PERCENT; # direct health restored
              set healthRestored currPower;
              muldiv healthRestored temp 100;
              unit.getHealth temp;
              #debug_log "HealWounds Hp restored " healthRestored temp hpCap;
              add healthRestored temp;
              limit_upper healthRestored hpCap; # limit healing to cap
              limit_lower healthRestored temp; # don't reduce health if it's above cap
              unit.setHealthWithOverkill healthRestored;
            end;
          end;

          begin; ### Servitor Enhancement
            var ptr RuleArmor armorRule;
            var int buffVal;

            damaging_item.getTag buffVal Tag.ITEM_SERVITOR_ENHANCER;
            if gt buffVal 0; # skip if not servitor enhancer
              unit.getRuleArmor armorRule;
              armorRule.getTag temp Tag.UNIT_TYPE_SERVITOR;
              unit.getTag temp2 Tag.SMT_SERVITOR_ENHANCED;
              if and gt temp 0 eq temp2 0; # only if unit is servitor and hasn't already been buffed
                unit.setTag Tag.SMT_SERVITOR_ENHANCED buffVal;
                unit.Stats.addFiring buffVal;
                unit.Stats.addMelee buffVal;
              else;
                set to_time 0;
              end;
            end;
          end;

          begin; ### Cloaking

            damaging_item.getTag temp Tag.ITEM_CLOAKING_EFFECT;
            if gt temp 0;
              unit.getTag temp2 Tag.UNIT_STEALTH_IS_ACTIVE;
              #debug_log "Cloaking Ping 2" temp temp2;
              if eq temp2 0; # only activate if unit is not already stealthed
                unit.setTag Tag.UNIT_STEALTH_IS_ACTIVE 1;
                unit.setTag Tag.UNIT_STEALTH_RANGE temp;
              end;
            end;
          end;

          ## END
          return;

    hitUnit:
      - new: SMTS_vulnerable_target #*** Script that amplifies incoming attacks based on vulnerability ***
        offset: 2
        code: |
          var int temp;
          var int temp2;

          attacker.getFaction temp;
          unit.getFaction temp2;
          if eq temp temp2; # don't amplify friendly effects
            return power part side;
          end;

          unit.getTag temp Tag.SMT_VULN_INTENSITY;
          if gt temp 0;
            add temp 100;
            #debug_log "VulnHit Ping1" temp power;
            muldiv power temp 100; # increase power of incoming hit by % of vulnerability
            #debug_log "VulnHit Ping2" temp power;
          end;

          return power part side;

      - new: SMTS_overwatch_reactionRefund #*** Script that grants bonus TUs when landing reaction shots if unit has been buffed with >100% Overwatch
        offset: 2.1
        code: |
          var int bonusTUs;
          var int spentTUs;
          var int maxTUs;
          var int temp;
          var int temp2;

          attacker.getFaction temp;
          battle_game.getTurnSide temp2;
          if eq temp temp2; # only trigger on reaction fire
            return power part side;
          end;

          attacker.getTag bonusTUs Tag.SMT_OVERWATCH_BUFF_EXCESS;
          if gt bonusTUs 0;
            attacker.getTimeUnits spentTUs;
            attacker.getTimeUnitsMax maxTUs;
            if lt spentTUs maxTUs;
              muldiv spentTUs 100 maxTUs; # get missing TUs as % of max
              set temp spentTUs;
              sub spentTUs 100;
              mul spentTUs -1;
              #debug_log "Vigilance Reaction: " bonusTUs spentTUs temp maxTUs;
              if lt bonusTUs spentTUs; #if there's not enough stored TUs for 100%
                add temp bonusTUs;
                muldiv temp maxTUs 100; # get absolute TU value
                attacker.setTimeUnits temp;
                set bonusTUs 0;
              else;
                sub bonusTUs spentTUs;
                attacker.setTimeUnits maxTUs;
              end;
              attacker.setTag Tag.SMT_OVERWATCH_BUFF_EXCESS bonusTUs;
            end;
          end;

          return power part side;

    healUnit:
      - new: SMTS_buff_medkit_trigger # Buffs applied via medkit
        offset: 20
        code: |
          var int turn;
          var int tuCost;
          var int temp;
          var int temp2;

          battle_game.getTurn turn;
          item.getActionCost.getTimeUnits tuCost actor battle_action_use;
          mul tuCost -1; # invert, don't refund TUs by default
          item.getPainKillerQuantity temp;
          if gt temp 900;
            item.setPainKillerQuantity 999; # infinite use
            set painkiller_recovery 0;
          end;

          begin; ### Jetpack
            var int flightTime;
            var int cooldownTime;

            item.getTag temp Tag.ActivateFlight;
            if eq temp 1;
              actor.getTag flightTime Tag.FlightTime;
              actor.getTag cooldownTime Tag.CooldownTime;
              if lt turn flightTime;
                set temp flightTime;
                sub temp turn;
                battle_game.flashMessage "STR_SCRIPT_FLIGHT_DURATION_LEFT" temp;
                abs tuCost; # refund TUs
              else lt turn cooldownTime;
                set temp cooldownTime;
                sub temp turn;
                battle_game.flashMessage "STR_SCRIPT_COOLDOWN_DURATION_LEFT" temp;
                abs tuCost; # refund TUs
              else;
                actor.setMovementType movement_type_fly;
                actor.getTag temp Tag.MaxFlight;
                actor.getTag temp2 Tag.MaxCoolDown;
                set cooldownTime turn;
                add cooldownTime temp;
                add cooldownTime temp2;
                actor.setTag Tag.CooldownTime cooldownTime;
                set flightTime turn;
                add flightTime temp;
                actor.setTag Tag.FlightTime flightTime;
                battle_game.flashMessage "STR_SCRIPT_FLIGHT_ACTIVE" temp;
              end;
            end;
          end;

          begin; ### Teleport
            var int flightTime;
            var int cooldownTime;

            actor.getTag temp Tag.UNIT_IS_TELEPORTING;
            item.getTag temp2 Tag.ITEM_IS_TELEPORTER;
            if ge temp 1; # unit already teleporting
              actor.setTag Tag.UNIT_IS_TELEPORTING 0;
              actor.MoveCost.setBaseTimePercent 100;
              actor.MoveCost.setBaseClimbEnergyPercent 100;
              actor.MoveCost.setBaseNormalEnergyPercent 100;
              actor.MoveCost.setBaseFlyEnergyPercent 100;
              actor.getOriginalMovementType temp;
              actor.setMovementType temp;
              actor.getTag temp Tag.UNIT_ENERGY_BEFORE_TELEPORT; # this assumes no weapon requires energy
              actor.setEnergy temp;
              abs tuCost; # refund TUs
              battle_game.flashMessage "STR_SCRIPT_TELEPORTER_SHUTTING_DOWN";
            else ge temp2 1;
              actor.getTag temp Tag.UNIT_LAST_ACTIVATED_TELEPORTER_TURN;
              if gt turn temp;
                actor.getEnergy temp;
                actor.setTag Tag.UNIT_ENERGY_BEFORE_TELEPORT temp;
                item.getTag temp Tag.ITEM_TELEPORTER_ENERGY;
                actor.setEnergy temp;
                actor.MoveCost.setBaseTimePercent 0;
                actor.MoveCost.setBaseClimbEnergyPercent 100;
                actor.MoveCost.setBaseNormalEnergyPercent 50;
                actor.MoveCost.setBaseFlyEnergyPercent 50;
                actor.setMovementType movement_type_fly;
                battle_game.flashMessage "STR_SCRIPT_TELEPORTER_STARTING_UP";
                actor.setTag Tag.UNIT_IS_TELEPORTING 1;
                item.getTag temp Tag.ITEM_TELEPORTER_COOLDOWN;
                add temp turn;
                actor.setTag Tag.UNIT_LAST_ACTIVATED_TELEPORTER_TURN temp;
              else; # if on cooldown
                sub temp turn;
                add temp 1;
                battle_game.flashMessage "STR_SCRIPT_COOLDOWN_DURATION_LEFT" temp;
                abs tuCost; # refund TUs
              end;
            end;
          end;

          begin; ### Self Shield
            var int shieldHP;
            var int cooldownTime;

            item.getTag shieldHP Tag.ITEM_ADDS_ENERGY_SHIELD_FROM_POWER;
            actor.getTag temp Tag.UNIT_SHIELD_COOLDOWN;
            #debug_log "techShield Ping " shieldHP temp;
            if gt shieldHP 0;
              if gt turn temp;
                actor.getTag temp Tag.UNIT_ENERGY_SHIELD_HP; # calc shield boost
                add shieldHP temp;
                actor.setTag Tag.UNIT_ENERGY_SHIELD_HP shieldHP;
                actor.getTag temp Tag.UNIT_ENERGY_SHIELD_DECAY; # calc shield decay
                item.getTag temp2 Tag.ITEM_SETS_ENERGY_SHIELD_DECAY;
                limit_lower temp temp2;
                actor.setTag Tag.UNIT_ENERGY_SHIELD_DECAY temp;
                item.getTag temp Tag.ITEM_EFFECT_DURATION; # set shield cooldown
                add temp turn;
                actor.setTag Tag.UNIT_SHIELD_COOLDOWN temp;
                battle_game.flashMessage "STR_SCRIPT_SHIELD_ACTIVE" shieldHP;
                #debug_log "techShield Success " shieldHP temp turn;
              else;
                #debug_log "techShield Failed " turn temp;
                sub temp turn;
                add temp 1;
                battle_game.flashMessage "STR_SCRIPT_COOLDOWN_DURATION_LEFT" temp;
                abs tuCost; # refund TUs
              end;
            end;


          end;

          if gt tuCost 0;
            actor.addTimeUnits tuCost; # refund cost if effect failed
          end;

          return;

      - delete: ROSIGMA_healU_limited_flight
      - delete: ROSIGMA_healU_start_teleport


    reactionUnitAction:
      - new: SMTS_haste_reactionbonus
        offset: 21
        code: |
          var int friendyReactionScore;
          var int enemyReactionScore;
          var int reactionBonus;
          var int temp;

          action_unit.getFaction temp;
          if neq temp FACTION_PLAYER;
            return reaction_chance;
          end;

          action_unit.getTag reactionBonus Tag.SMT_REFLEX_REACTION_BONUS;
          if eq reactionBonus 0;
            return reaction_chance;
          end;

          action_unit.Stats.getReactions friendyReactionScore;
          action_unit.getTimeUnits temp;
          mul friendyReactionScore temp;
          action_unit.getTimeUnitsMax temp;
          div friendyReactionScore temp;

          add friendyReactionScore reactionBonus; # flat bonus applied after TU% modifier

          reaction_unit.Stats.getReactions enemyReactionScore;
          reaction_unit.getTimeUnits temp;
          mul enemyReactionScore temp;
          reaction_unit.getTimeUnitsMax temp;
          div enemyReactionScore temp;
          #debug_log "HasteReaction Ping - " friendyReactionScore reactionBonus enemyReactionScore reaction_chance;

          if gt friendyReactionScore enemyReactionScore;
            return 0;
          end;

          return reaction_chance;

    recolorUnitSprite:
      - new: SMTS_vuln_recolor
        offset: 80
        code: |
          var int frame;
          var int frameLength;
          var int recolorPeriod;
          var int desync;
          var int color;
          var int newShade;
          var int temp;

          unit.getTag temp Tag.SMT_VULN_ENDTURN;
          if eq temp 0; # if not debuffed
            return new_pixel;
          end;

          # taken from traitor script
          # Check to make sure this unit isn't set to be recolored by a hit first
          unit.getTag frame Tag.UNIT_RECOLOR_START_FRAME;
          unit.getTag frameLength Tag.UNIT_RECOLOR_FRAME_LENGTH;

          if neq frame 0;
            set temp anim_frame;
            sub temp frame;
            if lt temp frameLength;
              return new_pixel;
            end;
          end;

          set recolorPeriod 32;
          set frameLength 8; #4

          unit.getTag desync Tag.UNIT_RECOLOR_DESYNC;
          add desync 3;
          set frame anim_frame;
          add frame desync;
          mod frame recolorPeriod;

          sub frame frameLength;
          sub frame 1;

          set color COLOR_X1_RED;
          set temp frameLength;
          sub temp frame;
          mul temp 2; # a parameter that creates a nice flash animation
          get_shade newShade new_pixel;
          sub newShade temp;

          if and gt newShade 3 lt newShade 16;
            set_shade new_pixel newShade;
            #set_color new_pixel color;
            set temp newShade;
            add temp frame;
            mod temp 2;
            if eq temp 1;
              set_color new_pixel 11; # light purple
            else eq temp 0;
              set_color new_pixel 12; # bright purple
            end;
          end;

          return new_pixel;




