extended:
  tags:
    RuleItem:
      SMT_VIGILIANCE_BUFF: int          # % of power added as overwatch bonus
      SMT_ITEM_MOVESPEED_BOOST: int     # limit on movespeed bonus provided by haste
      SMT_ITEM_REACTION_MOD: int        # % of power added as reaction bonus
      SMT_VULN_DEBUFF: int              # % of power added as vulnerability bonus
      SMT_VULN_DURATION: int            # length of debuff
      SMT_SIGNUM_DURATION: int          # length of Signum FA buff in turns
    RuleArmor:
      SMT_SIGNUM_ARMOR: int             # check for if is unit wearing a signum
    BattleUnit:
      SMT_VIGILIANCE_ENDTURN: int       # store buff duration
      SMT_OVERWATCH_BONUS: int          # stores units bonus to Overwatch
      SMT_VIGILIANCE_OVERFLOW: int      # overflow TUs from >100% vigilance buff that gets added as the unit reacts
      SMT_HASTE_ENDTURN: int            # store buff duration
      SMT_HASTE_SPEED_BONUS: int        # stores movement modifier from haste
      SMT_HASTE_REACTION_BONUS: int     # stores units reaction bonus
      SMT_VULN_ENDTURN: int             # store debuff duration
      SMT_VULN_INTENSITY: int           # store debuff strength
      SMT_SIGNUM_ORIGINAL_FA: int       # store original firing accuracy
      SMT_SIGNUM_ENDTURN: int           # store buff duration
      UNIT_MOVESPEED_MODIFIERS: int     # combined movespeed modifiers for a unit

  scripts:
    newTurnUnit:
      - new: SMTS_haste_removebuff #*** Script that removes haste bonus from unit once turn ends ***
        offset: 90.0
        code: |
          var int currTurn;
          var int endTurn;
          var int baseMove;
          var int hasteMove;

          if neq side 0; # only run at the start of the players turn
            return;
          end;
          unit.getTag endTurn Tag.SMT_HASTE_ENDTURN;
          battle_game.getTurn currTurn;
          if eq endTurn 0;
            return;
          end;
          if or le currTurn 1 ge currTurn endTurn; # if buff expires or it's turn 1 (entering a new stage of multi-part mission)
            unit.getTag hasteMove Tag.SMT_HASTE_SPEED_BONUS;
            if neq hasteMove 0;
              unit.getTag baseMove Tag.UNIT_MOVESPEED_MODIFIERS;
              sub baseMove hasteMove;
              unit.MoveCost.setBaseTimePercent baseMove;
              unit.setTag Tag.UNIT_MOVESPEED_MODIFIERS baseMove;
              unit.setTag Tag.SMT_HASTE_SPEED_BONUS 0; #cancel tag
            end;
            unit.setTag Tag.SMT_HASTE_REACTION_BONUS 0; #cancel tag
          end;
          return;

      - new: SMTS_vigilance_removebuff #*** Script that removes vigilance bonus from unit once turn ends ***
        offset: 90.1
        code: |
          var ptr RuleArmor unitArmor;
          var int currTurn;
          var int endTurn;
          var int temp;

          if neq side 0; # only run at the start of the players turn
            return;
          end;
          unit.getTag endTurn Tag.SMT_VIGILIANCE_ENDTURN;
          if eq endTurn 0;
            return;
          end;
          battle_game.getTurn currTurn;

          if or le currTurn 1 ge currTurn endTurn; # if buff expires or it's turn 1 (entering a new stage of multi-part mission)
            unit.setTag Tag.SMT_OVERWATCH_BONUS 0;
            unit.setTag Tag.SMT_VIGILIANCE_OVERFLOW 0;
            unit.setTag Tag.SMT_VIGILIANCE_ENDTURN 0; #cancel tags
            #debug_log "VigilanceEnd Ping" currTurn endTurn;
          end;
          return;

      - new: SMTS_vulnerability_removebuff #*** Script that removes vulnerability bonus from unit once duration ends ***
        offset: 90.2
        code: |
          var int currTurn;
          var int endTurn;
          var int temp;

          if neq side 0; # only run at the start of the players turn
            return;
          end;
          unit.getTag endTurn Tag.SMT_VULN_ENDTURN;
          if eq endTurn 0;
            return;
          end;
          battle_game.getTurn currTurn;
          #debug_log "VulnTurn Ping" endTurn currTurn;
          if or le currTurn 1 ge currTurn endTurn; # if buff expires or it's turn 1 (entering a new stage of multi-part mission)
            unit.setTag Tag.SMT_VULN_INTENSITY 0;
            unit.setTag Tag.SMT_VULN_ENDTURN 0;
          end;
          return;

      - new: SMTS_signum_removebuff #*** Script that removes FA bonuses from unit once turn ends ***
        offset: 90.3
        code: |
          var int faction;
          var int endTurn;
          var int originalFiring;

          unit.getTag endTurn Tag.SMT_SIGNUM_ENDTURN;
          unit.getTag originalFiring Tag.SMT_SIGNUM_ORIGINAL_FA;
          #debug_log "SignumRemoveBuff Pinged" endTurn originalFiring;
          if eq turn 1;
            set endTurn 0; # reset at the start for multi-stage missions
          end;

          if and neq originalFiring 0 le turn endTurn;
            #debug_log "Signum Restoring FA: " originalFiring;
            unit.Stats.setFiring originalFiring; 
            unit.setTag Tag.SMT_SIGNUM_ORIGINAL_FA 0; #cancel tag
          end;
          return;

    reactionUnitAction:
      - new: SMTS_haste_reactionbonus
        offset: 21
        code: |
          var int friendyReactionScore;
          var int enemyReactionScore;
          var int reactionBonus;
          var int temp;

          action_unit.getFaction temp;
          if neq temp FACTION_PLAYER;
            return reaction_chance;
          end;

          action_unit.getTag reactionBonus Tag.SMT_HASTE_REACTION_BONUS;
          if eq reactionBonus 0;
            return reaction_chance;
          end;

          action_unit.Stats.getReactions friendyReactionScore;
          action_unit.getTimeUnits temp;
          mul friendyReactionScore temp;
          action_unit.getTimeUnitsMax temp;
          div friendyReactionScore temp;

          add friendyReactionScore reactionBonus; # flat bonus applied after TU% modifier

          reaction_unit.Stats.getReactions enemyReactionScore;
          reaction_unit.getTimeUnits temp;
          mul enemyReactionScore temp;
          reaction_unit.getTimeUnitsMax temp;
          div enemyReactionScore temp;
          #debug_log "HasteReaction Ping - " friendyReactionScore reactionBonus enemyReactionScore reaction_chance;

          if gt friendyReactionScore enemyReactionScore;
            return 0;
          end;

          return reaction_chance;

    hitUnit:
      - new: SMTS_vulnerable_target #*** Script that amplifies incoming attacks based on vulnerability ***
        offset: 2
        code: |
          var int temp;
          var int temp2;

          attacker.getFaction temp;
          unit.getFaction temp2;
          if eq temp temp2; # don't amplify friendly effects
            return power part side;
          end;

          unit.getTag temp Tag.SMT_VULN_INTENSITY;
          if gt temp 0;
            add temp 100;
            #debug_log "VulnHit Ping1" temp power;
            muldiv power temp 100; # increase power of incoming hit by % of vulnerability
            #debug_log "VulnHit Ping2" temp power;
          end;

          return power part side;

      - new: SMTS_vigilance_reactionRefund #*** Script that grants bonus TUs when landing reaction shots if unit has been buffed with >100% Overwatch
        offset: 2.1
        code: |
          var int bonusTUs;
          var int spentTUs;
          var int maxTUs;
          var int temp;
          var int temp2;

          attacker.getFaction temp;
          battle_game.getTurnSide temp2;
          if eq temp temp2; # only trigger on reaction fire
            return power part side;
          end;

          attacker.getTag bonusTUs Tag.SMT_VIGILIANCE_OVERFLOW;
          if gt bonusTUs 0;
            attacker.getTimeUnits spentTUs;
            attacker.getTimeUnitsMax maxTUs;
            if lt spentTUs maxTUs;
              muldiv spentTUs 100 maxTUs; # get missing TUs as % of max
              set temp spentTUs;
              sub spentTUs 100;
              mul spentTUs -1;
              debug_log "Vigilance Reaction: " bonusTUs spentTUs temp maxTUs;
              if lt bonusTUs spentTUs; #if there's not enough stored TUs for 100%
                add temp bonusTUs;
                muldiv temp maxTUs 100; # get absolute TU value
                attacker.setTimeUnits temp;
                set bonusTUs 0;
              else;
                sub bonusTUs spentTUs;
                attacker.setTimeUnits maxTUs;
              end;
              attacker.setTag Tag.SMT_VIGILIANCE_OVERFLOW bonusTUs;
            end;
          end;

          return power part side;


    damageUnit:
      - new: SMTS_vigilance_buff
        offset: 3.1
        code: |
          var ptr RuleArmor armorRule;
          var int vigilBonus;
          var int vigilOverflow;
          var int temp;

          damaging_item.getTag temp Tag.SMT_VIGILIANCE_BUFF;

          if gt temp 0; # skip if doesn't boost overwatch
            set vigilBonus orig_power;
            muldiv vigilBonus temp 100;
            unit.getRuleArmor armorRule;
            armorRule.getTag temp Tag.ARMOR_OVERWATCH_TU_RESTORED; # add innate Overwatch from armor
            add vigilBonus temp;
            unit.getTag temp Tag.SMT_OVERWATCH_BONUS; # add any previous Overwatch buffs
            add vigilBonus temp;
            unit.getTag temp Tag.SMT_VIGILIANCE_OVERFLOW; # add any overflow from previous Overwatch buffs
            add vigilBonus temp;
            if gt vigilBonus 100; # if total >100, add overflow TUs
              set temp vigilBonus;
              sub temp 100;
              unit.getTimeUnitsMax vigilOverflow;
              muldiv vigilOverflow temp 100;
              unit.setTag Tag.SMT_VIGILIANCE_OVERFLOW vigilOverflow;
            end;
            limit vigilBonus 0 100;
            unit.setTag Tag.SMT_OVERWATCH_BONUS vigilBonus;
            #debug_log "Vigilance Ping" vigilBonus temp;

            battle_game.getTurn temp;
            add temp 1; #define end turn for buff
            unit.setTag Tag.SMT_VIGILIANCE_ENDTURN temp;
          end;

          return;

      - new: SMTS_haste_buff
        offset: 3.2
        code: |
          var int currentSpeed;
          var int originalSpeed;
          var int currentReactBonus;
          var int baseMove;
          var int temp;
          var int temp2;

          damaging_item.getTag temp Tag.SMT_ITEM_MOVESPEED_BOOST; # movespeed bonus
          #debug_log "HasteBuff Ping " temp;
          if gt temp 0;
          # Power <50 = no change, >=50 = 75% cost, >=100 50% cost (move bonus capped by item tag)
            set temp2 orig_power;
            div temp2 50;
            #debug_log "HasteBuff Power - " temp orig_power currPower temp2;
            limit temp2 0 temp; # eliminate negatives and cap power
            if gt temp2 0; # only continue if move cost would change
              mul temp2 -25;
              unit.getTag temp Tag.SMT_HASTE_SPEED_BONUS;
              if lt temp2 temp; # if new value is faster
                unit.getTag baseMove Tag.UNIT_MOVESPEED_MODIFIERS;
                sub baseMove temp; # remove old modifier
                add baseMove temp2; # add new modifier
                unit.setTag Tag.UNIT_STEALTH_MOVEPENALTY temp2;
                unit.setTag Tag.UNIT_MOVESPEED_MODIFIERS baseMove; # apply movement modifier
                add baseMove 100;
                limit_lower temp2 25;
                unit.MoveCost.setBaseTimePercent baseMove;
              end;
            end;
          end;

          damaging_item.getTag temp2 Tag.SMT_ITEM_REACTION_MOD; # reactions bonus
          if gt temp2 0;
            unit.getTag currentReactBonus Tag.SMT_HASTE_REACTION_BONUS;
            set temp orig_power;
            add temp 25; # make low power more effective and high power slightly less effective
            muldiv temp 3 2;
            muldiv temp temp2 100; # scale result by item %
            if gt temp currentReactBonus; # only change if new bonus would be an improvement
              unit.setTag Tag.SMT_HASTE_REACTION_BONUS temp;
            end;
            #debug_log "HasteBuff Reaction Bonus N/O" temp currentReactBonus;
          end;

          battle_game.getTurn temp;
          add temp 1; #define end turn for buff
          unit.setTag Tag.SMT_HASTE_ENDTURN temp;

          return;

      - new: SMTS_vulnerability_buff
        offset: 3.3
        code: |
          var int debuffVal;
          var int endTurn;
          var int temp;

          damaging_item.getTag temp Tag.SMT_VULN_DEBUFF;

          if gt temp 0; # skip if doesn't inflict vuln
            set debuffVal currPower;
            muldiv debuffVal temp 100;
            limit debuffVal 0 200; # cap at 300%
            unit.getTag temp Tag.SMT_VULN_INTENSITY;
            if gt debuffVal temp; #only change if it would be higher
              unit.setTag Tag.SMT_VULN_INTENSITY debuffVal;
              debug_log "VulnDebuff Ping 1" debuffVal;
              damaging_item.getTag debuffVal Tag.SMT_VULN_DURATION;
              battle_game.getTurn temp;
              add temp debuffVal; #define end turn for buff
              unit.getTag endTurn Tag.SMT_VULN_ENDTURN;
              if gt temp endTurn; # only set new endturn if incoming debuff duration is longer
                unit.setTag Tag.SMT_VULN_ENDTURN temp;
              end;
              #debug_log "VulnDebuff Ping 2" temp;
            end;
          end;
          return;


    recolorUnitSprite:
      - new: SMTS_vuln_recolor
        offset: 80
        code: |
          var int frame;
          var int frameLength;
          var int recolorPeriod;
          var int desync;
          var int color;
          var int newShade;
          var int temp;

          unit.getTag temp Tag.SMT_VULN_ENDTURN;
          if eq temp 0; # if not debuffed
            return new_pixel;
          end;

          # taken from traitor script
          # Check to make sure this unit isn't set to be recolored by a hit first
          unit.getTag frame Tag.UNIT_RECOLOR_START_FRAME;
          unit.getTag frameLength Tag.UNIT_RECOLOR_FRAME_LENGTH;

          if neq frame 0;
            set temp anim_frame;
            sub temp frame;
            if lt temp frameLength;
              return new_pixel;
            end;
          end;

          set recolorPeriod 32;
          set frameLength 8; #4

          unit.getTag desync Tag.UNIT_RECOLOR_DESYNC;
          add desync 3;
          set frame anim_frame;
          add frame desync;
          mod frame recolorPeriod;

          sub frame frameLength;
          sub frame 1;

          set color COLOR_X1_RED;
          set temp frameLength;
          sub temp frame;
          mul temp 2; # a parameter that creates a nice flash animation
          get_shade newShade new_pixel;
          sub newShade temp;

          if and gt newShade 3 lt newShade 16;
            set_shade new_pixel newShade;
            #set_color new_pixel color;
            set temp newShade;
            add temp frame;
            mod temp 2;
            if eq temp 1;
              set_color new_pixel 11; # light purple
            else eq temp 0;
              set_color new_pixel 12; # bright purple
            end;
          end;

          return new_pixel;



items:
  - type: STR_LIB_SPEED_TOME
    tags:
      SMT_ITEM_MOVESPEED_BOOST: 1
      SMT_ITEM_REACTION_MOD: 75

  - type: STR_LIB_SPEED_TOME_DW
    tags:
      SMT_ITEM_MOVESPEED_BOOST: 2
      SMT_ITEM_REACTION_MOD: 75

  - type: STR_SMT_SIGNUM
    tags:
      SMT_SIGNUM_DURATION: 1
    scripts:
      damageUnitAmmo: |
        var ptr RuleItem itemRuleset;
        var int statValue;
        var int buffTime;
        var int temp;

        damaging_item.getRuleItem itemRuleset;
        itemRuleset.getTag buffTime Tag.SMT_SIGNUM_DURATION;
        unit.getTag temp Tag.SMT_SIGNUM_ORIGINAL_FA; #used here to check if unit already has signum buff
        #debug_log "SignumBuff Pinged" buffTime temp;

        if neq temp 0; # skip if target already has signum buff
          #debug_log "SignumBuff Aborted - " signumUser temp;
          return;
        end;

        unit.Stats.getFiring statValue; #remember original Firing stat
        #debug_log "Signum values: " currPower statValue;
        if gt currPower statValue; # only boost if signum user FA is greater than the target FA
          unit.setTag Tag.SMT_SIGNUM_ORIGINAL_FA statValue;
          #debug_log "original FA: " statValue;
          set temp currPower;
          div temp 2;
          add statValue temp; # add half Signum user FA to target FA
          limit_upper statValue currPower; # don't exceed Signum user FA
          unit.Stats.setFiring statValue;
          #debug_log "buffed FA: " statValue;

          battle_game.getTurn temp;
          add temp buffTime; #define end turn for buff
          unit.setTag Tag.SMT_SIGNUM_ENDTURN temp;
        end;

        return;


