armors:
  - type: STR_CAPTAIN_UC # TERMINATOR CAPTAIN
    tags:
      SMT_ARMOR_HEAVY_WEAPON_USER: 1

  - type: STR_POWER_SUIT_UC # TERMINATOR
    tags:
      SMT_ARMOR_HEAVY_WEAPON_USER: 1

  - type: STR_TSARGENT_UC # TERMINATOR CYCLONE
    tags:
      SMT_ARMOR_HEAVY_WEAPON_USER: 1

  - type: STR_FLYING_SUIT_UC # TERMINATOR ASSAULT
    tags:
      SMT_ARMOR_HEAVY_WEAPON_USER: 1

  - type: STR_CHAP_TERMINATOR_UC # TERMINATOR CHAPLAIN
    tags:
      SMT_ARMOR_HEAVY_WEAPON_USER: 1

  - type: STR_LIB_TERMINATOR_UC # TERMINATOR LIBRARIAN
    tags:
      SMT_ARMOR_HEAVY_WEAPON_USER: 1
      
  - type: STR_DEV_ARMOR_UC #DEVASTATOR
    tags:
      SMT_ARMOR_HEAVY_WEAPON_USER: 2

### Deathwatch Armor HWP tags are defined in DW_armor.rul

extended:
  tags:
    RuleItem:
      ITEM_HAS_BIPOD: int
      ITEM_IS_HEAVY_WEAPON: int # infantry but not mounted/vehicle hwp - 1 = normal penalty, 2 = can't be reduced by armor bonus (see below) meant for snipers etc
    RuleArmor:
      SMT_ARMOR_HEAVY_WEAPON_USER: int # armor that counteracts the penalty for heavy weapons - 1 = no penalty, 2+ gives scaling reduction - 2 = 1/2, 3 = 2/3, 4 = 3/4 etc

  scripts:
    accuracyMultiplierBonusStats:
      - override: ROSIGMA_aMBS_tu_accuracy_penalty # modified to add HWP specialist armor that reduces/ignores the penalty
        offset: 31
        code: |
          var ptr RuleArmor unitArmor;
          var int temp;
          var int currentTU;
          var int accuracyScore;
          var int weaponWithBipod;
          var int kneeling;
          var int hwpUser;
          var int hwpPenalty;

          var ptr RuleItem rItem;

          weapon.getRuleItem rItem;
          rItem.getTag hwpPenalty Tag.ITEM_IS_HEAVY_WEAPON;
          if le hwpPenalty 0;
            return bonus; # final accuracy
          end;

          unit.getFaction temp;
          if eq temp FACTION_HOSTILE; #don't bother for AI
            return bonus; # final accuracy
          end;

          unit.getRuleArmor unitArmor;
          unitArmor.getTag hwpUser Tag.SMT_ARMOR_HEAVY_WEAPON_USER; #ignore if user has appropriate armor
          if and eq hwpUser 1 neq hwpPenalty 2; # HWP with value 2 can't be ignored by HWP specialist armor
            return bonus; # final accuracy
          end;

          unit.isKneeled kneeling; # 1 when kneeling
          rItem.getTag weaponWithBipod Tag.ITEM_HAS_BIPOD;

          unit.getTimeUnits currentTU; # absolute
          unit.getTimeUnitsMax temp;
          muldiv currentTU 100 temp; # relative
          # debug_log "currenTU %" currentTU;

          set temp bonus; # starting bonus

          if and gt currentTU 20 le currentTU 80;
            add currentTU 20; # start with 100 (80 + 20) % bonus
            muldiv bonus currentTU 100;
            # debug_log "Altered currenTU %" currentTU;
            # debug_log "20-80 bonus" bonus;
            sub currentTU 20;
          end;

          if le currentTU 20;
            muldiv bonus 40 100; # lower range is 40 (20 + 20)
            # debug_log "20 bonus" bonus;
          end;

          if and ge hwpUser 2 neq hwpPenalty 2; # adjusted penalty if wearing appropriate armor
            sub hwpUser 1;
            limit_lower hwpUser 1;
            mul bonus hwpUser;
            add bonus temp;
            add hwpUser 1;
            div bonus hwpUser; # (reduced bonus * hwpBonus + starting bonus) / hwpBonus
          end;

          if and eq kneeling 1 eq weaponWithBipod 1; # 1/3 penalty if kneeling with bipod
            add bonus temp;
            add bonus temp; # (current bonus + starting bonus * 2) / 3
            div bonus 3; # 1/3 penalty
            # debug_log "kneel+bipod bonus";
          end;

          if and eq kneeling 1 eq weaponWithBipod 0; # 1/2 penalty if kneeling without bipod
            add bonus temp; # (current bonus + starting bonus) / 2
            div bonus 2; # 1/2 penalty
          end;
          # debug_log "battle_action" battle_action;
          # debug_log "current bonus" bonus;


          return bonus; # final accuracy