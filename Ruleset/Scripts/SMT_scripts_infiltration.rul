extended:
  tagsFile: Ruleset/Scripts/SMT_tags.rul

  scripts:
    healUnit:
      - new: SMTS_infiltration_med # Toggle invisibility if conditions met
        offset: 22
        code: |
          var ptr RuleArmor armorRule;
          var int stealthRange;
          var int tuCost;
          var int baseMove;
          var int temp;
          var int temp2;

          item.getTag stealthRange Tag.ITEM_STEALTH_RANGE;
          if le stealthRange 0;
            return;
          end;

          item.setPainKillerQuantity 10; # infinite use
          item.getActionCost.getTimeUnits tuCost actor battle_action_use;
          actor.addTimeUnits tuCost; # refund cost if stealth isn't activated

          actor.getTag temp Tag.UNIT_STEALTH_IS_ACTIVE; # handle decloaking
          if gt temp 0;
            actor.getTag temp2 Tag.UNIT_DEACTIVATE_CHECK; # first time a unit tries to decloak display stealth info & confirmation message instead
            if eq temp2 0;
              actor.getTag temp2 Tag.UNIT_STEALTH_RANGE;
              battle_game.flashLongMessage "STR_SCRIPT_STEALTH_PREDEACTIVATE" temp temp2;
              actor.setTag Tag.UNIT_DEACTIVATE_CHECK 1;
              return;
            end;
            battle_game.flashMessage "STR_SCRIPT_CAMO_CLOAK_DEACTIVATE";
            actor.setTag Tag.UNIT_STEALTH_IS_ACTIVE 0; # disable stealth
            actor.setTag Tag.UNIT_STEALTH_RANGE 0;
            actor.getTag temp Tag.UNIT_STEALTH_MOVEPENALTY; # remove movement penalty
            if neq temp 0;
              actor.getTag baseMove Tag.UNIT_MOVESPEED_MODIFIERS;
              sub baseMove temp;
              actor.setTag Tag.UNIT_MOVESPEED_MODIFIERS baseMove;
              add baseMove 100;
              actor.MoveCost.setBaseTimePercent baseMove;
              actor.setTag Tag.UNIT_STEALTH_MOVEPENALTY 0;
              actor.setTag Tag.UNIT_CAMO_CLOAK_MOVE_COST_MULTIPLIER 0; # digin compatibility
              actor.getTag temp Tag.UNIT_DIG_IN_MOVE_PENALTY;
              if gt temp 0;
                actor.MoveCost.setBaseTimePercent temp; # handle digin
              end;
            end;
            return; # no TU cost for decloaking
          end;

          actor.getTag temp Tag.ARMOR_RESTEALTH_KILL_REQUIREMENT; # check kills required
          actor.getTag temp2 Tag.UNIT_LIKE_A_SHADOW_COUNTER;
          sub temp temp2;
          limit_lower temp 0;
          if gt temp 0; # if kill check fails
            battle_game.flashMessage "STR_SKILL_INFILTRATION_CHECK" temp;
            return;
          end;

          actor.getTag temp Tag.ARMOR_RESTEALTH_TURN_REQUIREMENT; # check turns required
          actor.getTag temp2 Tag.UNIT_STEALTH_CHARGE_TURN_COUNTER;
          sub temp temp2;
          limit_lower temp 0;
          if gt temp 0; # if turn check fails
            battle_game.flashMessage "STR_SCRIPT_INFILTRATION_RECHARGING" temp;
            return;
          end;

          item.getTag temp Tag.ITEM_EFFECT_DURATION;
          actor.setTag Tag.UNIT_STEALTH_IS_ACTIVE temp; # activate stealth
          actor.setTag Tag.UNIT_STEALTH_RANGE stealthRange;
          actor.setTag Tag.UNIT_LIKE_A_SHADOW_COUNTER 0; # reset kill counter
          actor.setTag Tag.UNIT_STEALTH_CHARGE_TURN_COUNTER 0; # reset turn counter
          battle_game.flashMessage "STR_SKILL_INFILTRATION_ACTIVATED" temp;

          actor.getTag temp Tag.UNIT_STEALTH_MOVEPENALTY; # calculate movespeed modifier
          item.getTag temp2 Tag.ITEM_STEALTH_MOVEPENALTY;
          actor.getTag baseMove Tag.UNIT_MOVESPEED_MODIFIERS;
          if gt temp2 temp; # only change if new movement modifier is slower
            sub baseMove temp; # remove old penalty
            actor.setTag Tag.UNIT_STEALTH_MOVEPENALTY temp2;
            add baseMove temp2; # apply new penalty
            actor.setTag Tag.UNIT_MOVESPEED_MODIFIERS baseMove;
            actor.setTag Tag.UNIT_CAMO_CLOAK_MOVE_COST_MULTIPLIER temp2; # digin compatibility
          end;
          add baseMove 100;
          actor.MoveCost.setBaseTimePercent baseMove;

          actor.getTag temp Tag.UNIT_DIG_IN_MOVE_PENALTY;
          if gt temp 0;
            actor.MoveCost.setBaseTimePercent temp; # handle digin
          end;

          actor.getTimeUnits temp;
          sub temp tuCost;
          actor.setTimeUnits temp; # apply TU cost

          return;

    damageUnit:
      - new: SMTS_infiltration_assassincloak
        offset: 80  # after reveals
        code: |
          var int temp;
          var int temp2;

          unit.getFaction temp;
          if neq temp FACTION_HOSTILE; # ignore friendly fire and civilians
            #debug_log "Assassin Fail - Wrong Faction " unit temp FACTION_HOSTILE;
            return;
          end;

          battle_game.getTurnSide temp; # only during player turn
          if neq temp 0;
            #debug_log "Assassin Fail - Wrong Side " temp;
            return;
          end;

          if or eq battle_action battle_action_snapshot eq battle_action battle_action_autoshoot; # ignore snap or autoshots
            #debug_log "Assassin Fail - Wrong Action " battle_action battle_action_snapshot battle_action_autoshoot;
            return;
          end;

          unit.getHealth temp;
          if and lt to_health temp gt temp 0; # only killing blows
            #debug_log "Assassin Fail - Not kill " to_health temp;
            return;
          end;

          weapon_item.getTag temp2 Tag.ITEM_STEALTH_ASSASSIN_WEAPON; # only assassin weapons
          if eq temp2 0;
            #debug_log "Assassin Fail - Invalid Item " weapon_item temp;
            return;
          end;

          attacker.getTag temp Tag.ARMOR_CLOAKED_ASSASSIN_TYPE; # only assassin units who match item type
          #debug_log "Assassin Check - User/Item " temp temp2 weapon_item;
          div temp temp2;
          mod temp 2;
          if neq temp 1;
            #debug_log "Assassin Fail - User/Item Mismatch " temp temp2;
            return;
          end;

          attacker.getTag temp Tag.ARMOR_CLOAKED_ASSASSIN_RANGE;
          attacker.setTag Tag.UNIT_STEALTH_RANGE temp;
          attacker.setTag Tag.UNIT_STEALTH_IS_ACTIVE 1;
          #debug_log "Assassin Success " temp;

          return;


    skillUseUnit:
      - new: SMTS_infiltration_skill # Toggle invisibility if conditions met
        offset: 10
        code: |
          var ptr RuleArmor armorRule;
          var int stealthRange;
          var int baseMove;
          var int temp;
          var int temp2;

          skill.getTag stealthRange Tag.SKILL_STEALTH_RANGE;
          if eq stealthRange 0;
            return;
          end;

          actor.getTag temp Tag.UNIT_STEALTH_IS_ACTIVE; # handle decloaking
          skill.getTag temp2 Tag.SKILL_STEALTH_CHECK;
          if or gt temp 0 eq temp2 -1;
            battle_game.flashMessage "STR_SCRIPT_STEALTH_DEACTIVATE";
            actor.setTag Tag.UNIT_STEALTH_IS_ACTIVE 0; # disable stealth
            actor.setTag Tag.UNIT_STEALTH_RANGE 0;
            actor.getTag temp Tag.UNIT_STEALTH_MOVEPENALTY; # remove movement penalty
            if neq temp 0;
              actor.getTag baseMove Tag.UNIT_MOVESPEED_MODIFIERS;
              sub baseMove temp;
              actor.setTag Tag.UNIT_MOVESPEED_MODIFIERS baseMove;
              add baseMove 100;
              actor.MoveCost.setBaseTimePercent baseMove;
              actor.setTag Tag.UNIT_STEALTH_MOVEPENALTY 0;
              actor.setTag Tag.UNIT_CAMO_CLOAK_MOVE_COST_MULTIPLIER 0; # digin compatibility
              actor.getTag temp Tag.UNIT_DIG_IN_MOVE_PENALTY;
              if gt temp 0;
                actor.MoveCost.setBaseTimePercent temp; # handle digin
              end;
            end;
            set spend_tu 0; # no TU cost for decloaking
            return;
          end;

          actor.getTag temp Tag.ARMOR_RESTEALTH_KILL_REQUIREMENT; # check kills required
          actor.getTag temp2 Tag.UNIT_LIKE_A_SHADOW_COUNTER;
          sub temp temp2;
          limit_lower temp 0;
          if gt temp 0; # if kill check fails
            battle_game.flashMessage "STR_SKILL_INFILTRATION_CHECK" temp;
            set spend_tu 0; # no TU cost for failure
            return;
          end;

          actor.getTag temp Tag.ARMOR_RESTEALTH_TURN_REQUIREMENT; # check turns required
          actor.getTag temp2 Tag.UNIT_STEALTH_CHARGE_TURN_COUNTER;
          sub temp temp2;
          limit_lower temp 0;
          if gt temp 0; # if turn check fails
            battle_game.flashMessage "STR_SCRIPT_INFILTRATION_RECHARGING" temp;
            set spend_tu 0; # no TU cost for failure
            return;
          end;

          skill.getTag temp Tag.SKILL_STEALTH_DURATION;
          actor.setTag Tag.UNIT_STEALTH_IS_ACTIVE temp; # activate stealth
          actor.setTag Tag.UNIT_STEALTH_RANGE stealthRange;
          actor.setTag Tag.UNIT_LIKE_A_SHADOW_COUNTER 0; # reset kill counter
          actor.setTag Tag.UNIT_STEALTH_CHARGE_TURN_COUNTER 0; # reset turn counter
          battle_game.flashMessage "STR_SKILL_INFILTRATION_ACTIVATED" temp;

          actor.getTag temp Tag.UNIT_STEALTH_MOVEPENALTY; # calculate movespeed modifier
          skill.getTag temp2 Tag.SKILL_STEALTH_MOVEPENALTY;
          actor.getTag baseMove Tag.UNIT_MOVESPEED_MODIFIERS;
          if gt temp2 temp; # only change if new movement modifier is slower
            sub baseMove temp; # remove old penalty
            actor.setTag Tag.UNIT_STEALTH_MOVEPENALTY temp2;
            add baseMove temp2; # apply new penalty
            actor.setTag Tag.UNIT_MOVESPEED_MODIFIERS baseMove;
            actor.setTag Tag.UNIT_CAMO_CLOAK_MOVE_COST_MULTIPLIER temp2; # digin compatibility
          end;
          add baseMove 100;
          actor.MoveCost.setBaseTimePercent baseMove;
          set spend_tu 1;

          actor.getTag temp Tag.UNIT_DIG_IN_MOVE_PENALTY;
          if gt temp 0;
            actor.MoveCost.setBaseTimePercent temp; # handle digin
          end;

          return;

      - new: SMTS_infiltration_check_skill # display conditions needed for restealthing
        offset: 10
        code: |
          var int killReq;
          var int turnReq;
          var int temp;

          skill.getTag temp Tag.SKILL_STEALTH_CHECK;
          if le temp 0;
            return;
          end;
          set spend_tu 0; # no TU cost

          actor.getTag killReq Tag.ARMOR_RESTEALTH_KILL_REQUIREMENT; # check kills required
          actor.getTag temp Tag.UNIT_LIKE_A_SHADOW_COUNTER;
          sub killReq temp;
          limit_lower killReq 0;

          actor.getTag turnReq Tag.ARMOR_RESTEALTH_TURN_REQUIREMENT; # check turns required
          actor.getTag temp Tag.UNIT_STEALTH_CHARGE_TURN_COUNTER;
          sub turnReq temp;
          limit_lower turnReq 0;

          if and gt killReq 0 gt turnReq 0; # need kills & turns
            battle_game.flashMessage "STR_SCRIPT_STEALTH_KILLTURN_REQ" killReq turnReq;
          else and gt killReq 0 eq turnReq 0; # need kills
            battle_game.flashMessage "STR_SCRIPT_STEALTH_KILL_REQ" killReq;
          else and eq killReq 0 gt turnReq 0; # need turns
            battle_game.flashMessage "STR_SCRIPT_STEALTH_TURN_REQ" killReq;
          else;
            battle_game.flashMessage "STR_SCRIPT_STEALTH_NO_REQ" killReq;
          end;

          return;


      - delete: ROSIGMA_sUU_infiltration_shadow
      - delete: ROSIGMA_sUU_infiltration_camo_cloak

    newTurnUnit:
      - new: SMTS_nTU_decrement_stealth # replace Rosigma version to handle movespeed properly
        offset: 2
        code: |
          var int stealthTimer;
          var int temp;
          var int temp2;
          var ptr RuleArmor myRuleArmor;

          battle_game.getTurnSide temp; # trigger only on the same turn as the unit's faction
          unit.getFaction temp2;
          if neq temp temp2;
            return;
          end;

          battle_game.getTurn temp;
          unit.getTag stealthTimer Tag.UNIT_STEALTH_IS_ACTIVE; # get the unit's current stealth counter
          if and eq temp 0 gt stealthTimer 0; # end any active stealth on the first turn - catch for multi-part missions
            unit.setTag Tag.UNIT_STEALTH_IS_ACTIVE 1; #
          end;

          unit.setTag Tag.UNIT_DEACTIVATE_CHECK 0; # reset deactivation check

          unit.getRuleArmor myRuleArmor;
          if le stealthTimer 0;
            myRuleArmor.getTag temp Tag.ARMOR_RESTEALTH_TURN_REQUIREMENT; #check to see if we need turns to restealth
            if gt temp 0;
              unit.getTag temp2 Tag.UNIT_STEALTH_CHARGE_TURN_COUNTER;
              if lt temp2 temp;
                sub temp temp2;
                add temp2 1;
                unit.setTag Tag.UNIT_STEALTH_CHARGE_TURN_COUNTER temp2;
                battle_game.flashMessage "STR_SCRIPT_INFILTRATION_RECHARGING" temp;
              else;
                battle_game.flashMessage "STR_SCRIPT_INFILTRATION_RECHARGED";
              end;
            end;
            return;
          end;

          sub stealthTimer 1; # decrement the counter by 1;
          unit.setTag Tag.UNIT_STEALTH_IS_ACTIVE stealthTimer;

          if lt stealthTimer 1;
            battle_game.flashMessage "STR_SCRIPT_INFILTRATION_NO_TIME_REMAINING";
            unit.setTag Tag.UNIT_STEALTH_RANGE 0;
            unit.getTag temp Tag.UNIT_STEALTH_MOVEPENALTY; # remove movement penalty
            if neq temp 0;
              unit.getTag temp2 Tag.UNIT_MOVESPEED_MODIFIERS;
              sub temp2 temp;
              unit.setTag Tag.UNIT_MOVESPEED_MODIFIERS temp2;
              add temp2 100;
              unit.MoveCost.setBaseTimePercent temp2;
              unit.setTag Tag.UNIT_STEALTH_MOVEPENALTY 0;
              unit.setTag Tag.UNIT_CAMO_CLOAK_MOVE_COST_MULTIPLIER 0; # digin compatibility
              unit.getTag temp Tag.UNIT_DIG_IN_MOVE_PENALTY;
              if gt temp 0;
                unit.MoveCost.setBaseTimePercent temp; # handle digin
              end;
            end;
            return;
          end;

          battle_game.flashMessage "STR_SCRIPT_INFILTRATION_TIME_REMAINING" stealthTimer;
          return;

      - new: SMTS_nTU_set_stealth # Infiltrator script - replace Rosigma version to use SMT variables
        offset: 3
        code: |
          var int temp;
          var int temp2;
          var ptr RuleArmor myRuleArmor;

          battle_game.getTurn temp;
          if gt temp 1; # we don't care about Turns beyond turn 1; abort.
            return;
          end;

          battle_game.getTurnSide temp; # trigger only on the same turn as the unit's faction
          unit.getFaction temp2;
          if neq temp temp2;
            return;
          end;

          unit.getRuleArmor myRuleArmor;
          myRuleArmor.getTag temp2 Tag.ARMOR_IS_INFILTRATOR; # get the unit's infiltrator value

          if le temp2 0;
            return;
          end;

          unit.setTag Tag.UNIT_STEALTH_IS_ACTIVE temp2; # set our stealth counter to the Infiltrator value
          myRuleArmor.getTag temp Tag.ARMOR_INFILTRATOR_RANGE;
          if eq temp 0; # if not set make unit undetectable
            set temp -1;
          end;
          unit.setTag Tag.UNIT_STEALTH_RANGE temp; # set stealth range
          battle_game.flashMessage "STR_SCRIPT_INFILTRATION_UNIT_STEALTHED" temp2;
          return;

      - delete: ROSIGMA_nTU_infiltration_set_stealth
      - delete: ROSIGMA_nTU_infiltration_decrement_stealth

    hitUnit:
      - new: SMTS_stealth_deactivate_on_hit # replace Rosigma script to handle movespeed properly
        offset: 5.1
        code: |
          var int temp;
          var int temp2;

          unit.getTag temp Tag.UNIT_STEALTH_IS_ACTIVE;
          if or lt temp 1 eq power 0; # ignore anything with power reduced to 0
            return power part side;
          end;

          # disable stealth for unit from non-impact damage
          if or eq damaging_type 0 eq damaging_type 6 eq damaging_type 10; # ignore support, smoke & impact damage
            return power part side;
          else;
            battle_game.flashMessage "STR_SCRIPT_INFILTRATION_NO_TIME_REMAINING";
            unit.setTag Tag.UNIT_STEALTH_IS_ACTIVE 0;
            unit.setTag Tag.UNIT_STEALTH_RANGE 0;
            unit.getTag temp Tag.UNIT_STEALTH_MOVEPENALTY; # remove movement penalty
            if neq temp 0;
              unit.getTag temp2 Tag.UNIT_MOVESPEED_MODIFIERS;
              #debug_log "StealthReveal1 " temp temp2;
              sub temp2 temp;
              unit.setTag Tag.UNIT_MOVESPEED_MODIFIERS temp2;
              add temp2 100;
              #debug_log "StealthReveal2 " temp temp2;
              unit.MoveCost.setBaseTimePercent temp2;
              unit.setTag Tag.UNIT_STEALTH_MOVEPENALTY 0;
              unit.setTag Tag.UNIT_CAMO_CLOAK_MOVE_COST_MULTIPLIER 0; # digin compatibility
              unit.getTag temp Tag.UNIT_DIG_IN_MOVE_PENALTY;
              if gt temp 0;
                unit.MoveCost.setBaseTimePercent temp; # handle digin
              end;
            end;
          end;

          return power part side;

      - new: SMTS_stealth_deactivate_on_attack # replace Rosigma script to handle movespeed properly
        offset: 5.2
        code: |
          var int temp;
          var int temp2;

          attacker.getTag temp Tag.UNIT_STEALTH_IS_ACTIVE;
          if or lt temp 1 eq power 0; # ignore anything with power reduced to 0
            return power part side;
          end;

          battle_game.flashMessage "STR_SCRIPT_INFILTRATION_NO_TIME_REMAINING";
          attacker.setTag Tag.UNIT_STEALTH_IS_ACTIVE 0; # disable stealth
          attacker.setTag Tag.UNIT_STEALTH_RANGE 0;
          attacker.getTag temp Tag.UNIT_STEALTH_MOVEPENALTY; # remove movement penalty
          if neq temp 0;
            attacker.getTag temp2 Tag.UNIT_MOVESPEED_MODIFIERS;
            #debug_log "StealthReveal1 " temp temp2;
            sub temp2 temp;
            attacker.setTag Tag.UNIT_MOVESPEED_MODIFIERS temp2;
            add temp2 100;
            #debug_log "StealthReveal2 " temp temp2;
            attacker.MoveCost.setBaseTimePercent temp2;
            attacker.setTag Tag.UNIT_STEALTH_MOVEPENALTY 0;
            attacker.setTag Tag.UNIT_CAMO_CLOAK_MOVE_COST_MULTIPLIER 0; # digin compatibility
            attacker.getTag temp Tag.UNIT_DIG_IN_MOVE_PENALTY;
            if gt temp 0;
              attacker.MoveCost.setBaseTimePercent temp; # handle digin
            end;
          end;
          return power part side;

      - delete: ROSIGMA_hU_infiltration_stealth_deactivate_on_hit
      - delete: ROSIGMA_hU_infiltration_stealth_deactivate_on_attack

    visibilityUnit:
      - new: SMTS_stealth_proximity_detection # modified for custom detection ranges
        offset: 5
        code: |
          var int temp;

          target_unit.getTag temp Tag.UNIT_STEALTH_IS_ACTIVE;

          if lt temp 1;
            return current_visibility visibility_mode;
          end;

          target_unit.getTag temp Tag.UNIT_STEALTH_RANGE;
          mul temp 16; # 1 tile ~= 15.75
          #debug_log "Stealth VisCheck" temp distance;
          if lt distance temp;
            #debug_log "Stealth VisCheck Detected" temp distance;
            return current_visibility visibility_mode; # ignore stealth if they're within detection range
          end;

          return 0 visibility_mode;

      - delete: ROSIGMA_vU_infiltration_proximity_detection

    reactionUnitAction:
      - new: SMTS_stealth_no_reactions # modified to account for detection range and not bother negating enemy reactions (they're already negated by not being visible)
        offset: 10
        code: |
          var int temp;

          reaction_unit.getTag temp Tag.UNIT_STEALTH_RANGE;
          #debug_log "Stealth ReactCheckUA" temp distance;
          if neq temp 0;
            mul temp 15; # 1 tile ~= 15.75
            if gt distance temp; # prevent reactions if enemy is out of detection range
              return 0;
            end;
          end;

          return reaction_chance;

      - delete: ROSIGMA_rUA_infiltration_no_reactions




