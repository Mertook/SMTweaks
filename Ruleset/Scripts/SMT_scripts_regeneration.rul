extended:
  tagsFile: Ruleset/Scripts/SMT_tags.rul

  scripts:
    newTurnUnit:
      #*** Script that regenerates unit health depending on lost health % ***
      - new: SMTS_regen_health
        offset: 1
        code: |
          var ptr RuleArmor unitArmor;
          var ptr RuleSoldier unitSoldier;
          var int unitMaxHp;
          var int unitCurrentHp;
          var int unitLowestHp;
          var int regenHpFlat;
          var int regenHpPercent;
          var int temp;
          var int temp2;

          unit.getHealth unitCurrentHp;
          unit.getHealthMax unitMaxHp;
          if or le unitCurrentHp 0 eq unitCurrentHp unitMaxHp; # skip if unit is dead or max hp
            return;
          end;

          unit.getTag unitLowestHp Tag.SMT_LOWEST_HEALTH;
          if or lt unitCurrentHp unitLowestHp eq unitLowestHp 0; # adjust lowest HP level if needed
            set unitLowestHp unitCurrentHp;
            unit.setTag Tag.SMT_LOWEST_HEALTH unitLowestHp;
          end;

          unit.getFaction temp;
          if neq side temp; # don't trigger on others' turns
            return;
          end;

          unit.getRuleSoldier unitSoldier;
          unitSoldier.getTag temp Tag.UNIT_REGENERATE_HEALTH_BURN_TOGGLE;
          unit.getRuleArmor unitArmor;
          unitArmor.getTag temp2 Tag.ARMOR_REGENERATE_HEALTH_BURN_TOGGLE;
          add temp temp2;
          unit.getFire temp2;
          if and gt temp 0 gt temp2 0; # skip if fire is disabling regeneration
            return;
          end;

          unit.getRuleSoldier unitSoldier;
          unitSoldier.getTag regenHpFlat Tag.UNIT_REGENERATE_HEALTH_FLAT;
          unitArmor.getTag temp Tag.ARMOR_REGENERATE_HEALTH_FLAT;
          add regenHpFlat temp;
          unitSoldier.getTag regenHpPercent Tag.UNIT_REGENERATE_HEALTH_PERCENT;
          unitArmor.getTag temp Tag.ARMOR_REGENERATE_HEALTH_PERCENT;
          add regenHpPercent temp; #combine regen bonuses from armor & soldiertype
          if and le regenHpFlat 0 le regenHpPercent 0;  #skip if regen is <=0
            return;
          end;

          unitSoldier.getTag temp Tag.UNIT_REGENERATE_HEALTH_SOFTCAP;
          unitArmor.getTag temp2 Tag.ARMOR_REGENERATE_HEALTH_SOFTCAP;
          if gt temp temp2;
            set temp temp2; # pick higher of two limits
          end;

          if gt temp 0; # if unit has a regeneration limit calculate it based on max hp - lowest hp
            sub unitMaxHp unitLowestHp;
            muldiv unitMaxHp temp 100;
            add unitMaxHp unitLowestHp;
          end;

          if ge unitCurrentHp unitMaxHp; #skip if hp is >=cap
            #debug_log "Regen Aborted - Max/Current Hp: " unitMaxHp unitCurrentHp;
            return;
          end;

          if gt regenHpPercent 0; # if unit has percentage health regen calculate it
            set temp unitCurrentHp;
            muldiv temp regenHpPercent 100;
            add regenHpFlat temp;
          end;

          add unitCurrentHp regenHpFlat;
          limit_upper unitCurrentHp unitMaxHp; #don't overheal if regen would go over max
          #debug_log "New Health: " unitCurrentHp unitMaxHp;
          unit.setHealthWithOverkill unitCurrentHp;
          return;

      - new: SMTS_regen_wounds
        offset: 2
        code: |
          var ptr RuleSoldier unitSoldier;
          var int woundRecovery;
          var int temp;

          unit.getFaction temp;
          if neq side temp; # don't trigger on others' turns
            return;
          end;

          unit.getFatalwoundsTotal temp;
          if lt temp 1; # skip if unit isn't wounded
            return;
          end;

          unit.getRuleSoldier unitSoldier;
          unitSoldier.getTag woundRecovery Tag.SMT_UNIT_REGEN_WOUND;
          if eq woundRecovery 0; # skip if unit doesn't regen wounds
            return;
          end;

          begin; #from rosigma wound regen
            var int numWounds 0;
            var int healWounds woundRecovery;
            loop var i 6; #cycle through the body parts
              unit.getFatalwounds numWounds i; #check the number of wounds in this bodypart
              if and gt numWounds 0 gt healWounds 0; #if there are any wounds in this body part and any heals remaining, remove as many as we can
                set temp numWounds; #save the initial number of wounds
                sub numWounds healWounds; #remove wounds equal to our heal wound count
                sub healWounds temp; #decrement the number of heals by the initial number of wounds
                limit_lower numWounds 0; #ensure wounds do not go below 0
                limit_lower healWounds 0; #ensure heals do not go below 0
                unit.setFatalwounds i numWounds; #remove the wounds
              end;
            end;
          end;

          return;

      - new: SMTS_regen_armor
        offset: 1
        code: |
          var int armorRecovery;
          var int temp;
          var int temp2;

          unit.getFaction temp;
          if neq side temp; # don't trigger on others' turns
            return;
          end;

          unit.getTag armorRecovery Tag.ARMOR_REGENERATE_DURABILITY;
          if eq armorRecovery 0; # skip if unit doesn't regen armor
            return;
          end;

          loop var i 5; #cycle through the armor sides
            unit.getArmor temp i;
            unit.getArmorMax temp2 i;
            #debug_log "RegenArmor Pre  " i temp temp2 armorRecovery;
            add temp armorRecovery;
            limit_upper temp temp2;
            unit.setArmor temp i;
            #debug_log "RegenArmor Post " i temp temp2 armorRecovery;
          end;

          return;

    returnFromMissionUnit:
      #*** Calculate Soldier recovery time based on % of missing health rather than absolute ***
      - new: SMTS_medbay_calculation
        offset: 99
        code: |
          var ptr RuleSoldier soldierRuleset;
          var ptr RuleArmor unitArmor;
          var int woundTimeMultiplier;
          var int recoveryHealth;
          var int temp;
          var int temp2;

          # if and gt health_loss 0 eq recovery_time 0; # skip if the unit was hurt but instantly recovers because of armor tag
            # #debug_log "Recovery Aborted - Armor Tag?: " health_loss final_health_loss recovery_time;
            # return;
          # end;

          unit.getRuleSoldier soldierRuleset;
          soldierRuleset.getTag woundTimeMultiplier Tag.SOLDIER_WOUND_TIME_MULTIPLIER;
          if lt woundTimeMultiplier 0; # skip if the unit ignores recovery
            #debug_log "Recovery Aborted - Soldier Tag: " woundTimeMultiplier health_loss recovery_time;
            set recovery_time 0;
            return;
          end;

          unit.getTag recoveryHealth Tag.SMT_LOWEST_HEALTH;
          if le recoveryHealth 0; # skip if the unit never got its health adjusted
            #debug_log "Recovery Aborted - Lowest Health Not Set: " recoveryHealth health_loss recovery_time;
            set recovery_time 0;
            return;
          end;
          unit.getHealthMax temp; # get max health
          unit.getRuleArmor unitArmor;
          unitArmor.Stats.getHealth temp2;
          sub temp temp2; # ignore health granted by armor
          #debug_log "Recovery Health: " recoveryHealth temp temp2 recovery_time;
          if ge recoveryHealth temp; # if units lowest HP is greater or equal to its max without armor bonuses, no recovery time
            #debug_log "Recovery Aborted - Health Above Max: " recoveryHealth temp health_loss recovery_time;
            set recovery_time 0;
            return;
          end;
          muldiv recoveryHealth 100 temp; # get % of max health
          sub recoveryHealth 101; # +1 - 1 health remaining returns as 100 instead of 99
          abs recoveryHealth;
          div recoveryHealth 2; # reduce to 1/2 - max penalty 50 (40-60) days
          #debug_log "RecoveryTime Calc: " recoveryHealth health_loss recovery_time;
          if le recoveryHealth 0; # if recovery penalty ends up at <=0, no recovery time - shouldn't ever happen
            set recovery_time 0;
            return;
          end;
          set temp recoveryHealth;
          set temp2 recoveryHealth;
          muldiv temp 80 100;
          muldiv temp2 120 100; # 80-120% random range
          battle_game.randomRange recoveryHealth temp temp2;
          #debug_log "RecoveryTime Roll: " recoveryHealth temp temp2;

          unit.getTag temp Tag.SMT_RECOVERY_PENALTY;
          add recoveryHealth temp; # add recovery penalty time

          if gt woundTimeMultiplier 0; #adjust based on soldier recovery speed
            muldiv recoveryHealth woundTimeMultiplier 100;
            #debug_log "RecoveryTime -  Soldier Bonus: " recoveryHealth woundTimeMultiplier;
          end;

          unit.getTag temp Tag.UNIT_BIONICS; # adjust for bionics bonus
          if eq temp 1;
            muldiv recoveryHealth 2 3; # 2/3 recovery time for bionics (original 1/2)
            #debug_log "RecoveryTime -  Bionics Bonus: " recoveryHealth temp;
          end;

          battle_game.getTag temp Tag.SMT_FAST_RECOVERY_PEAK; # adjust for apoth bonus
          if gt temp 0;
            sub temp 100;
            abs temp;
            muldiv recoveryHealth temp 100;
            #debug_log "RecoveryTime -  Bionics Bonus: " recoveryHealth temp;
          end;

          set recovery_time recoveryHealth;
          #debug_log "Final RecoveryTime: " recovery_time;

          return;


